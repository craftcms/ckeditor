<?php

namespace craft\ckeditor\migrations;

use Craft;
use craft\ckeditor\Field;
use craft\db\Migration;
use craft\db\Query;
use craft\db\Table;
use craft\elements\Entry;
use craft\fieldlayoutelements\CustomField;
use craft\helpers\ArrayHelper;

/**
 * Base convert matrix content migration class.
 *
 * This is extended by content migrations generated by the `ckeditor/convert/matrix` command.
 *
 * @since 4.2.0
 */
class BaseConvertMatrixContentMigration extends Migration
{
    public string $ckeFieldUid;
    public ?string $outgoingEntryTypeUid;
    public ?string $outgoingTextFieldUid;
    public ?string $replacementEntryTypeUid;

    public function safeUp(): bool
    {
        $fieldsService = Craft::$app->getFields();
        $ckeField = $fieldsService->getFieldByUid($this->ckeFieldUid);

        if (!$ckeField) {
            echo "Invalid field UUID: $this->ckeFieldUid";
            return false;
        }

        if (!$ckeField instanceof Field) {
            echo "$ckeField->name is not a CKEditor field.";
            return false;
        }

        $outgoingEntryType = null;
        $outgoingTextField = null;
        $replacementEntryType = null;

        $entriesService = Craft::$app->getEntries();
        if ($this->outgoingEntryTypeUid) {
            $outgoingEntryType = $entriesService->getEntryTypeByUid($this->outgoingEntryTypeUid);
            if (!$outgoingEntryType) {
                echo "Invalid entry type UUID: $this->outgoingEntryTypeUid";
                return false;
            }

            if ($this->outgoingTextFieldUid) {
                $outgoingTextFieldLayoutElement = $outgoingEntryType->getFieldLayout()->getElementByUid($this->outgoingTextFieldUid);
                if (!$outgoingTextFieldLayoutElement instanceof CustomField) {
                    echo "Invalid field layout element UUID: $this->outgoingTextFieldUid";
                    return false;
                }
                $outgoingTextField = $outgoingTextFieldLayoutElement->getField();
            }
        }

        if ($this->replacementEntryTypeUid) {
            $replacementEntryType = $entriesService->getEntryTypeByUid($this->replacementEntryTypeUid);
            if (!$replacementEntryType) {
                echo "Invalid entry type UUID: $this->replacementEntryTypeUid";
                return false;
            }
        }

        $elementsService = Craft::$app->getElements();

        // get all the owner element IDs that have nested entries for this field
        $ownerIds = (new Query())
            ->select('o.ownerId')
            ->from(['e' => Table::ENTRIES])
            ->innerJoin(['o' => Table::ELEMENTS_OWNERS], '[[o.elementId]] = [[e.id]]')
            ->where(['e.fieldId' => $ckeField->id])
            ->groupBy('ownerId')
            ->column();

        foreach ($ownerIds as $ownerId) {
            // get all the nested entries for the owner/field
            /** @var Entry[] $allNestedEntries */
            $allNestedEntries = Entry::find()
                ->ownerId($ownerId)
                ->fieldId($ckeField->id)
                ->siteId('*')
                ->drafts(null)
                ->revisions(null)
                ->trashed(null)
                ->status(null)
                ->all();

            // group by site ID
            /** @var array<int,Entry[]> $groupedNestedEntries */
            $groupedNestedEntries = ArrayHelper::index($allNestedEntries, null, [
                fn(Entry $entry) => $entry->siteId,
            ]);

            foreach ($groupedNestedEntries as $nestedEntries) {
                $owner = $nestedEntries[0]->getOwner();

                echo sprintf('    > Updating %s %s ("%s") in %s … ', $owner::lowerDisplayName(),  $owner->id, $owner->getUiLabel(), $owner->getSite()->name);

                // if we have the top-level HTML field defined:
                if ($outgoingEntryType !== null && $replacementEntryType !== null) {
                    $value = '';
                    // iterate through each nested entry,
                    foreach ($nestedEntries as $entry) {
                        // if the nested entry is the one containing the top-level field,
                        // get its content and place it before the rest of that entry’s content
                        // followed by the <craft-entry data-entry-id=\"<nested entry id>\"></craft-entry>;
                        // also change the entry type to the ID of the duplicate that doesn’t contain that field
                        if ($entry->type->uid === $outgoingEntryType->uid) {
                            $value .= $entry->getFieldValue($outgoingTextField->handle);
                            $value .= sprintf('<craft-entry data-entry-id="%s"></craft-entry>', $entry->id);
                            $entry->setTypeId($replacementEntryType->id);
                            $elementsService->saveElement($entry, false);
                        } else {
                            // for other nested entries add the <craft-entry data-entry-id=\"<nested entry id>\”></craft-entry>
                            $value .= sprintf('<craft-entry data-entry-id="%s"></craft-entry>', $entry->id);
                        }
                    }
                } else {
                    // populate the CKEditor field with content which is: <craft-entry data-entry-id=\"<nested entry id>\”></craft-entry>
                    $valueIds = array_map(fn(Entry $entry) => $entry->id, $nestedEntries);
                    $value = '';
                    foreach ($valueIds as $id) {
                        $value .= sprintf('<craft-entry data-entry-id="%s"></craft-entry>', $id);
                    }
                }

                $owner->setFieldValue($ckeField->handle, $value);
                $elementsService->saveElement($owner, false);
                echo "✓\n";
            }
        }

        return true;
    }
}
