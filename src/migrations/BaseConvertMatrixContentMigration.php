<?php

namespace craft\ckeditor\migrations;

use Craft;
use craft\ckeditor\Field;
use craft\db\Migration;
use craft\elements\Entry;
use craft\fieldlayoutelements\CustomField;
use craft\helpers\ArrayHelper;

/**
 * Base convert matrix content migration class.
 *
 * This is extended by content migrations generated by the `ckeditor/convert/matrix` command.
 *
 * @since 4.2.0
 */
class BaseConvertMatrixContentMigration extends Migration
{
    public string $ckeFieldUid;
    public ?string $outgoingEntryTypeUid;
    public ?string $outgoingTextFieldUid;
    public ?string $replacementEntryTypeUid;

    public function safeUp(): bool
    {
        $fieldsService = Craft::$app->getFields();
        $ckeField = $fieldsService->getFieldByUid($this->ckeFieldUid);

        if (!$ckeField) {
            echo "Invalid field UUID: $this->ckeFieldUid";
            return false;
        }

        if (!$ckeField instanceof Field) {
            echo "$ckeField->name is not a CKEditor field.";
            return false;
        }

        echo '    > Starting content conversion … ';

        $outgoingEntryType = null;
        $outgoingTextField = null;
        $replacementEntryType = null;

        $entriesService = Craft::$app->getEntries();
        if ($this->outgoingEntryTypeUid) {
            $outgoingEntryType = $entriesService->getEntryTypeByUid($this->outgoingEntryTypeUid);
            if (!$outgoingEntryType) {
                echo "Invalid entry type UUID: $this->outgoingEntryTypeUid";
                return false;
            }

            if ($this->outgoingTextFieldUid) {
                $outgoingTextFieldLayoutElement = $outgoingEntryType->getFieldLayout()->getElementByUid($this->outgoingTextFieldUid);
                if (!$outgoingTextFieldLayoutElement instanceof CustomField) {
                    echo "Invalid field layout element UUID: $this->outgoingTextFieldUid";
                    return false;
                }
                $outgoingTextField = $outgoingTextFieldLayoutElement->getField();
            }
        }

        if ($this->replacementEntryTypeUid) {
            $replacementEntryType = $entriesService->getEntryTypeByUid($this->replacementEntryTypeUid);
            if (!$replacementEntryType) {
                echo "Invalid entry type UUID: $this->replacementEntryTypeUid";
                return false;
            }
        }

        // get all the nested entries belonging to the field we’re converting
        /** @var Entry[] $allNestedEntries */
        $allNestedEntries = Entry::find()
            ->fieldId($ckeField->id)
            ->drafts(null)
            ->revisions(null)
            ->trashed(null)
            ->status(null)
            ->all();

        // group them by ownerId
        /** @var array<int,Entry[]> $groupedNestedEntries */
        $groupedNestedEntries = ArrayHelper::index($allNestedEntries, null, [
            fn(Entry $entry) => $entry->ownerId,
        ]);

        // iterate through all the nested entries
        foreach ($groupedNestedEntries as $nestedEntries) {
            $owner = $nestedEntries[0]->getOwner();

            // if we have the top-level HTML field defined:
            if ($outgoingEntryType !== null && $replacementEntryType !== null) {
                $value = '';
                // iterate through each nested entry,
                foreach ($nestedEntries as $entry) {
                    // if the nested entry is the one containing the top-level field,
                    // get its content and place it before the rest of that entry’s content
                    // followed by the <craft-entry data-entry-id=\"<nested entry id>\"></craft-entry>;
                    // also change the entry type to the ID of the duplicate that doesn’t contain that field
                    if ($entry->type->uid === $outgoingEntryType->uid) {
                        $value .= $entry->getFieldValue($outgoingTextField->handle);
                        $value .= '<craft-entry data-entry-id="' . $entry->id . '"></craft-entry>';
                        $entry->setTypeId($replacementEntryType->id);
                        Craft::$app->getElements()->saveElement($entry, false);
                    } else {
                        // for other nested entries add the <craft-entry data-entry-id=\"<nested entry id>\”></craft-entry>
                        $value .= '<craft-entry data-entry-id="' . $entry->id . '"></craft-entry>';
                    }
                }
            } else {
                // populate the CKEditor field with content which is: <craft-entry data-entry-id=\"<nested entry id>\”></craft-entry>
                $valueIds = array_map(fn(Entry $entry) => $entry->id, $nestedEntries);
                $value = '';
                foreach ($valueIds as $id) {
                    $value .= '<craft-entry data-entry-id="' . $id . '"></craft-entry>';
                }
            }

            $owner->setFieldValue($ckeField->handle, $value);

            // save each owner
            Craft::$app->getElements()->saveElement($owner, false);
        }

        echo "✓\n";
        return true;
    }
}
